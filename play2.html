<!DOCTYPE html>
<html>
<head>
    <title>豆腐女孩-中央固定版</title>
    <style>
        body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background: linear-gradient(#87CEEB, #98FB98); font-family: Arial, sans-serif; }
        canvas { border: 2px solid #ddd; border-radius: 10px; cursor: pointer; }
        #info { margin-top: 10px; color: #333; text-align: center; }
    </style>
</head>
<body>
    <canvas id="game" width="400" height="600"></canvas>
    <div id="info">點擊跳躍 | 完美落地得分翻倍 | 按R重啟 | 起始10分 | 豆腐堆到中央自動跟隨</div>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        
        // 遊戲狀態 - 豆腐從下方開始
        let gameState = {
            girl: { x: 200, y: 520, vy: 0, radius: 15, grounded: true, jumpCooldown: 0 },
            tofuStack: [{ x: 180, y: 550, w: 40, h: 40 }],  // 起始下方
            currentTofu: { x: 170, y: 510, w: 40, h: 40, dir: 1, speed: 1.5 },
            score: 10,
            gameOver: false,
            cameraY: 0,
            cameraActive: false,  // 攝像機是否啟動
            keys: {}
        };

        function initGame() {
            gameState = {
                girl: { x: 200, y: 520, vy: 0, radius: 15, grounded: true, jumpCooldown: 0 },
                tofuStack: [{ x: 180, y: 550, w: 40, h: 40 }],
                currentTofu: { x: 170, y: 510, w: 40, h: 40, dir: 1, speed: 1.5 },
                score: 10,
                gameOver: false,
                cameraY: 0,
                cameraActive: false,
                keys: {}
            };
        }

        function updateCamera() {
            const topTofu = gameState.tofuStack[gameState.tofuStack.length - 1];
            
            // 當豆腐堆超過10層或topTofu.y < 300時啟動攝像機
            if (!gameState.cameraActive && (gameState.tofuStack.length > 10 || topTofu.y < 300)) {
                gameState.cameraActive = true;
            }
            
            if (gameState.cameraActive) {
                // 保持頂層豆腐在畫面中央 (Y=280)
                gameState.cameraY = topTofu.y - 280;
            }
        }

        function drawGirl(cameraY) {
            const g = gameState.girl;
            const screenY = g.y - cameraY;
            ctx.save();
            ctx.translate(g.x, screenY);
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            ctx.arc(0, -g.radius, g.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffc0cb';
            ctx.fillRect(-8, -g.radius + 5, 16, 20);
            ctx.restore();
        }

        function drawTofu(stack, cameraY) {
            ctx.fillStyle = '#fffacd';
            ctx.shadowColor = '#ffeb99';
            ctx.shadowBlur = 5;
            stack.forEach((t) => {
                const screenY = t.y - cameraY;
                if (screenY > -50 && screenY < 650) {
                    ctx.fillRect(t.x, screenY, t.w, t.h);
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#f0e68c';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(t.x, screenY, t.w, t.h);
                }
            });
        }

        function drawCurrentTofu(cameraY) {
            const t = gameState.currentTofu;
            const screenY = t.y - cameraY;
            if (screenY > -50 && screenY < 650) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(t.x, screenY, t.w, t.h);
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.strokeRect(t.x, screenY, t.w, t.h);
            }
        }

        function update() {
            if (gameState.gameOver) return;
            const g = gameState.girl;
            const topTofu = gameState.tofuStack[gameState.tofuStack.length - 1];

            g.jumpCooldown = Math.max(0, g.jumpCooldown - 1);
            if (!g.grounded) {
                g.vy += 0.4;
                g.y += g.vy;
            }

            // 更新攝像機
            updateCamera();

            // 當前豆腐移動
            gameState.currentTofu.x += gameState.currentTofu.dir * gameState.currentTofu.speed;
            if (gameState.currentTofu.x <= 140 || gameState.currentTofu.x >= 220) {
                gameState.currentTofu.dir *= -1;
            }
            gameState.currentTofu.speed = Math.min(3, gameState.currentTofu.speed + 0.002);

            // 碰撞檢測
            const tofuCenter = topTofu.x + topTofu.w / 2;
            const girlCenter = g.x;
            const dist = Math.abs(girlCenter - tofuCenter);
            
            if (g.y + g.radius >= topTofu.y && g.x > topTofu.x - 10 && g.x < topTofu.x + topTofu.w + 10) {
                g.grounded = true;
                g.y = topTofu.y - g.radius * 2;
                g.vy = 0;
                
                if (dist < 8) {
                    gameState.score += 20;
                    g.y -= 5; // 完美彈跳
                    setTimeout(() => { g.y += 5; }, 100);
                } else {
                    gameState.score += 10;
                }

                // 生成新豆腐
                const newTofu = { x: gameState.currentTofu.x, y: topTofu.y - 40, w: 40, h: 40 };
                gameState.tofuStack.push(newTofu);
                gameState.currentTofu.y -= 40;
                gameState.currentTofu.x = 170 + Math.random() * 60;
                gameState.currentTofu.dir = Math.random() > 0.5 ? 1 : -1;
                g.y -= 40;
            }

            // 遊戲結束
            if (g.y > gameState.tofuStack[gameState.tofuStack.length - 1].y + 100) {
                gameState.gameOver = true;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, 400, 600);
            const cameraY = gameState.cameraY;
            
            // 背景
            const grad = ctx.createLinearGradient(0, 0, 0, 600);
            grad.addColorStop(0, '#87CEEB');
            grad.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 400, 600);

            drawTofu(gameState.tofuStack, cameraY);
            drawCurrentTofu(cameraY);
            drawGirl(cameraY);

            // UI
            ctx.fillStyle = '#000';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`分數: ${gameState.score}`, 20, 50);
            ctx.font = '18px Arial';
            ctx.fillStyle = gameState.cameraActive ? '#4CAF50' : '#FF9800';
            ctx.fillText(`攝像機: ${gameState.cameraActive ? '啟動' : '待機'}`, 20, 80);
            
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, 400, 600);
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('遊戲結束!', 200, 280);
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.fillText(`最終分數: ${gameState.score}`, 200, 320);
                ctx.fillText('按 R 重啟', 200, 350);
                ctx.textAlign = 'left';
            } else {
                ctx.textAlign = 'left';
            }
        }

        function jump() {
            const g = gameState.girl;
            if (g.grounded && g.jumpCooldown === 0 && !gameState.gameOver) {
                g.vy = -14;
                g.grounded = false;
                g.jumpCooldown = 10;
            }
        }

        canvas.addEventListener('click', jump);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'r' && gameState.gameOver) {
                initGame();
            }
        });

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
    </script>
</body>
</html>
